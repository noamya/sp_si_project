from scipy.io import wavfile
import numpy as np
import scipy as sp


def get_test_data(channel="r"):
    fs, data = wavfile.read("test_data/Ilg_Fuoco_1.wav")
    data_r, data_l = np.transpose(data)
    if channel == "r":
        return fs, data_r
    elif channel == "l":
        return fs, data_l
    else:
        raise Exception("Channel must be either 'l' or 'r'")


def get_random_pm1_matrix(rows, cols):
    """
    Builds a random +-1 matrix in numpy array format with shape (rows, cols)
    """
    return (-1) ** np.random.randint(0, 2, (rows, cols))


def get_random_sparse_vector(n, d, minv=-1, maxv=1):
    """
    generates a random d-sparse array of size n with nnz values in the range (minv, maxv)
    :param n: dimension
    :param d: number of nnz
    :param minv: lower bound of possible nnz values
    :param maxv: upper bound of possible nnz values
    """
    x = np.zeros(n)
    x[np.random.choice(np.arange(0, n), d, replace=False)] = (np.random.random(d)*(maxv - minv) + minv)
    return x


def idtft(k_range, X):
    """
    Performs the inverse idtft
    x[k] = 1/(2*pi) * Integral_[-pi,pi] X(w)e^{iwk}
    :param k_range: the values of k for which we want to calculate x[k]
    :param X: An array representing the values of X in the range [-pi,pi]
    :return: {x[k] | k in k_range}
    """
    r = np.linspace(-np.pi, np.pi, X.size)
    res = 2*np.pi/X.size
    expmat = np.transpose(np.array([k_range])) @ np.array([r])
    integrand = res * X * np.exp(1j*expmat)
    integral_value = np.sum(integrand, axis=1)
    return 1/(2*np.pi) * integral_value


def dtft(x, x_range, fft_size=2**15):
    """
    Performs the dtft of a series x[k]:
    X(w) = sum_[-inf, inf] x[k] * e^(-jwk)
    at 'fft_size' equally spaced values W in the range [-pi, pi]
    :param x: the input series to the dtft
    :param x_range: the indexes at which x is given
    :param fft_size: the resolution of the computation
    :return:
    """
    assert fft_size >= np.max(np.abs(x_range))
    fft_buffer = np.zeros(fft_size)
    fft_buffer[x_range] = x
    return sp.fft.fftshift(sp.fft.fft(fft_buffer))

def calculate_correction_filter(s, T_res, T_sample, M):
    """
    Computes the digital correction filter h corresponding to the reconstruction of a SI signal generated by
    a kernel s. In practice, this means h = IDTFT{ 1 / DTFT{ r_ss[kT_sample] } }.
    :param s: the kernel generating the SI space
    :param T_res: the resolution at which it is given.
    :param T_sample: the rate of innovation of the SI signal
    :param M: The bounds of the result h. That is - h is given at the values k=-M,...,M
    :return: The correction filter M
    """
    rss = sp.signal.correlate(s, s, mode="full")
    assert np.isclose(rss[len(rss)//2], np.sum(s*s))
    interpolator = sp.interpolate.interp1d(np.arange(-s.size+1, s.size)*T_res, rss)
    rnt = interpolator(np.arange(0, (s.size-1)*T_res, T_sample))
    R = dtft(np.append(rnt[::-1], rnt[1:]), np.arange(-rnt.size+1, rnt.size))
    H = 1/R
    dfilter_range = np.arange(-M, M+1)
    return idtft(dfilter_range, H)


def project_into_si_signal(x, T_res, s, T):
    """
    Project a signal x into SI space with generator s. Creates the closest SI signal to x in L2.
    :param x: The signal
    :param T_res: The resolution at which it is given
    :param s: the generator of the SI space
    :param T: The rate of innovation of the SI space
    :return: A signal
    """
    xs = sp.signal.oaconvolve(x, s, mode='same')
    interpolator = sp.interpolate.interp1d(
        np.arange(len(xs))*T_res,
        xs,
        bounds_error=False,
        fill_value=(0, 0)
    )
    sample_times = np.arange(0, T_res*len(x), T)
    samples_xs = interpolator(sample_times)
    correction_filter = calculate_correction_filter(s, T_res, T, 30)
    dn = sp.signal.oaconvolve(samples_xs, correction_filter, mode='same')
    T_ratio = T / T_res
    assert np.isclose(T/T_res, int(T/T_res))
    dn_delta_train = np.zeros(x.size)
    indices = np.arange(0, x.size, T_ratio)
    assert np.allclose(indices, np.int64(indices))
    indices = np.int64(indices)
    dn_delta_train[indices] = dn
    return sp.signal.oaconvolve(dn_delta_train, s, mode="same")


def DFT(x):
    """
    Function to calculate the
    discrete Fourier Transform
    of a 1D real-valued signal x
    """
    N = len(x)
    n = np.arange(N)
    k = n.reshape((N, 1))
    e = np.exp(-2j * np.pi * k * n / N)
    X = np.dot(e, x)
    return X
